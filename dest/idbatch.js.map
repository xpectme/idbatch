{
  "version": 3,
  "sources": ["../mod.ts"],
  "sourcesContent": ["// deno-lint-ignore-file no-explicit-any\n\ninterface IDBXAddCommand<T> {\n  storeName: string;\n  method: \"add\";\n  data: T | T[];\n  key?: IDBValidKey;\n}\n\ninterface IDBXPutCommand<T> {\n  storeName: string;\n  method: \"put\";\n  data: T | T[];\n  key?: IDBValidKey;\n}\n\ninterface IDBXDeleteKeys {\n  keys: IDBValidKey[];\n}\n\ninterface IDBXDeleteKey {\n  key: IDBValidKey | IDBKeyRange;\n}\n\ninterface IDBXDeleteCommandBase {\n  storeName: string;\n  method: \"del\";\n}\n\ntype IDBXDeleteCommand =\n  & IDBXDeleteCommandBase\n  & (\n    | IDBXDeleteKeys\n    | IDBXDeleteKey\n  );\n\ninterface IDBXClearCommand {\n  storeName: string;\n  method: \"clear\";\n}\n\ninterface IDBXGetCommand {\n  storeName: string;\n  method: \"get\";\n  query: IDBValidKey;\n}\n\ninterface IDBXGetAllCommand {\n  storeName: string;\n  method: \"getAll\";\n  query?: IDBValidKey | IDBKeyRange;\n  count?: number;\n}\n\ninterface IDBXGetAllKeysCommand {\n  storeName: string;\n  method: \"getAllKeys\";\n  query: IDBValidKey | IDBKeyRange;\n  count?: number;\n}\n\ninterface IDBXGetKeyCommand {\n  storeName: string;\n  method: \"getKey\";\n  query: IDBValidKey;\n}\n\ninterface IDBXCountCommand {\n  storeName: string;\n  method: \"count\";\n  query: IDBValidKey | IDBKeyRange;\n}\n\ntype IDBXCommand<T> =\n  | IDBXAddCommand<T>\n  | IDBXPutCommand<T>\n  | IDBXDeleteCommand\n  | IDBXClearCommand\n  | IDBXGetCommand\n  | IDBXGetAllCommand\n  | IDBXGetAllKeysCommand\n  | IDBXGetKeyCommand\n  | IDBXCountCommand;\n\ninterface IDBXBatchResult<T> {\n  add: number;\n  put: number;\n  del: boolean;\n  clear: boolean;\n  get: T;\n  getAll: T[];\n  getAllKeys: IDBValidKey[];\n  getKey: IDBValidKey;\n  count: number;\n}\n\ntype IDBXBatchResultItem<\n  T = any,\n  K extends keyof IDBXBatchResult<T> = keyof IDBXBatchResult<T>,\n> = [\n  K,\n  IDBXBatchResult<T>[K],\n];\n\nfunction read<T>(\n  emit: IDBRequest<T>,\n  method: keyof IDBXBatchResult<T>,\n  results: IDBXBatchResultItem[],\n) {\n  const index = results.length;\n  results.push([method, undefined as any]);\n  emit.onsuccess = (event) => {\n    const value = (event.target as IDBRequest<T>).result;\n    results[index] = [method, value === undefined ? true : value];\n  };\n  emit.onerror = () => {\n    results[index] = [method, false];\n  };\n}\n\nexport default function idbatch<T>(\n  db: IDBDatabase,\n  commands: IDBXCommand<T>[],\n  mode: IDBTransactionMode,\n) {\n  const set = new Set(commands.map((c) => c.storeName));\n  const storeNames = Array.from(set);\n\n  const tx = db.transaction(storeNames, mode);\n  const results: IDBXBatchResultItem[] = [];\n  for (const command of commands) {\n    const store = tx.objectStore(command.storeName);\n    switch (command.method) {\n      case \"add\": {\n        const { data, key } = command;\n        if (Array.isArray(data)) {\n          for (const item of data) {\n            read(store.add(item, key), \"add\", results);\n          }\n        } else {\n          read(store.add(data, key), \"add\", results);\n        }\n        break;\n      }\n      case \"put\": {\n        const { data, key } = command;\n        if (Array.isArray(data)) {\n          for (const item of data) {\n            read(store.put(item, key), \"put\", results);\n          }\n        } else {\n          read(store.put(data, key), \"put\", results);\n        }\n        break;\n      }\n      case \"del\": {\n        if (\"keys\" in command) {\n          for (const key of command.keys) {\n            read(store.delete(key), \"del\", results);\n          }\n        } else if (\"key\" in command) {\n          read(store.delete(command.key), \"del\", results);\n        }\n        break;\n      }\n      case \"clear\": {\n        read(store.clear(), \"clear\", results);\n        break;\n      }\n      case \"get\": {\n        const { query } = command;\n        read(store.get(query), \"get\", results);\n        break;\n      }\n      case \"getAll\": {\n        const { query, count } = command;\n        read(store.getAll(query, count), \"getAll\", results);\n        break;\n      }\n      case \"getAllKeys\": {\n        const { query, count } = command;\n        read(store.getAllKeys(query, count), \"getAllKeys\", results);\n        break;\n      }\n      case \"getKey\": {\n        const { query } = command;\n        read(store.getKey(query), \"getKey\", results);\n        break;\n      }\n      case \"count\": {\n        const { query } = command;\n        read(store.count(query), \"count\", results);\n        break;\n      }\n    }\n  }\n\n  return {\n    abort: () => tx.abort(),\n    completed: new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve(results);\n      tx.onerror = () => reject(tx.error);\n    }),\n  } as const as {\n    abort: () => void;\n    completed: Promise<IDBXBatchResultItem<T>[]>;\n  };\n}\n"],
  "mappings": "AAwGA,SAASA,EACPC,EACAC,EACAC,EACA,CACA,IAAMC,EAAQD,EAAQ,OACtBA,EAAQ,KAAK,CAACD,EAAQ,MAAgB,CAAC,EACvCD,EAAK,UAAaI,GAAU,CAC1B,IAAMC,EAASD,EAAM,OAAyB,OAC9CF,EAAQC,CAAK,EAAI,CAACF,EAAQI,IAAU,OAAY,GAAOA,CAAK,CAC9D,EACAL,EAAK,QAAU,IAAM,CACnBE,EAAQC,CAAK,EAAI,CAACF,EAAQ,EAAK,CACjC,CACF,CAEe,SAARK,EACLC,EACAC,EACAC,EACA,CACA,IAAMC,EAAM,IAAI,IAAIF,EAAS,IAAKG,GAAMA,EAAE,SAAS,CAAC,EAC9CC,EAAa,MAAM,KAAKF,CAAG,EAE3BG,EAAKN,EAAG,YAAYK,EAAYH,CAAI,EACpCP,EAAiC,CAAC,EACxC,QAAWY,KAAWN,EAAU,CAC9B,IAAMO,EAAQF,EAAG,YAAYC,EAAQ,SAAS,EAC9C,OAAQA,EAAQ,OAAQ,CACtB,IAAK,MAAO,CACV,GAAM,CAAE,KAAAE,EAAM,IAAAC,CAAI,EAAIH,EACtB,GAAI,MAAM,QAAQE,CAAI,EACpB,QAAWE,KAAQF,EACjBjB,EAAKgB,EAAM,IAAIG,EAAMD,CAAG,EAAG,MAAOf,CAAO,OAG3CH,EAAKgB,EAAM,IAAIC,EAAMC,CAAG,EAAG,MAAOf,CAAO,EAE3C,KACF,CACA,IAAK,MAAO,CACV,GAAM,CAAE,KAAAc,EAAM,IAAAC,CAAI,EAAIH,EACtB,GAAI,MAAM,QAAQE,CAAI,EACpB,QAAWE,KAAQF,EACjBjB,EAAKgB,EAAM,IAAIG,EAAMD,CAAG,EAAG,MAAOf,CAAO,OAG3CH,EAAKgB,EAAM,IAAIC,EAAMC,CAAG,EAAG,MAAOf,CAAO,EAE3C,KACF,CACA,IAAK,MAAO,CACV,GAAI,SAAUY,EACZ,QAAWG,KAAOH,EAAQ,KACxBf,EAAKgB,EAAM,OAAOE,CAAG,EAAG,MAAOf,CAAO,MAE/B,QAASY,GAClBf,EAAKgB,EAAM,OAAOD,EAAQ,GAAG,EAAG,MAAOZ,CAAO,EAEhD,KACF,CACA,IAAK,QAAS,CACZH,EAAKgB,EAAM,MAAM,EAAG,QAASb,CAAO,EACpC,KACF,CACA,IAAK,MAAO,CACV,GAAM,CAAE,MAAAiB,CAAM,EAAIL,EAClBf,EAAKgB,EAAM,IAAII,CAAK,EAAG,MAAOjB,CAAO,EACrC,KACF,CACA,IAAK,SAAU,CACb,GAAM,CAAE,MAAAiB,EAAO,MAAAC,CAAM,EAAIN,EACzBf,EAAKgB,EAAM,OAAOI,EAAOC,CAAK,EAAG,SAAUlB,CAAO,EAClD,KACF,CACA,IAAK,aAAc,CACjB,GAAM,CAAE,MAAAiB,EAAO,MAAAC,CAAM,EAAIN,EACzBf,EAAKgB,EAAM,WAAWI,EAAOC,CAAK,EAAG,aAAclB,CAAO,EAC1D,KACF,CACA,IAAK,SAAU,CACb,GAAM,CAAE,MAAAiB,CAAM,EAAIL,EAClBf,EAAKgB,EAAM,OAAOI,CAAK,EAAG,SAAUjB,CAAO,EAC3C,KACF,CACA,IAAK,QAAS,CACZ,GAAM,CAAE,MAAAiB,CAAM,EAAIL,EAClBf,EAAKgB,EAAM,MAAMI,CAAK,EAAG,QAASjB,CAAO,EACzC,KACF,CACF,CACF,CAEA,MAAO,CACL,MAAO,IAAMW,EAAG,MAAM,EACtB,UAAW,IAAI,QAAQ,CAACQ,EAASC,IAAW,CAC1CT,EAAG,WAAa,IAAMQ,EAAQnB,CAAO,EACrCW,EAAG,QAAU,IAAMS,EAAOT,EAAG,KAAK,CACpC,CAAC,CACH,CAIF",
  "names": ["read", "emit", "method", "results", "index", "event", "value", "idbatch", "db", "commands", "mode", "set", "c", "storeNames", "tx", "command", "store", "data", "key", "item", "query", "count", "resolve", "reject"]
}
